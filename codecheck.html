<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python コードチェッカー (バグ修正版)</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.js"></script>

    <style>
        :root {
            --dark-bg: #202020;
            --panel-bg: #2d2d2d;
            --light-text: #E0E0E0;
            --blue-accent: #0070C0;
            --orange-accent: #F4800C;
            --red-error: #E57373;
            --yellow-warning: #fdd835;
            --grey-border: #7F7F7F;
            --grey-button: #757575;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--light-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Yu Gothic", YuGothic, "Hiragaino Kaku Gothic ProN", Meiryo, sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            display: flex;
            width: 100%;
            height: 60vh;
            background-color: var(--panel-bg);
        }

        .panel {
            padding: 20px;
            box-sizing: border-box;
        }

        .left-panel {
            flex: 1;
            border-right: 3px solid var(--grey-border);
            display: flex;
            flex-direction: column;
            background-color: #202123;
            padding: 0;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .CodeMirror {
            font-size: 16px;
            line-height: 1.5;
            height: 100%;
        }

        .button-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        #execute-btn,
        #reset-btn {
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 1.0rem;
            font-weight: bold;
            cursor: pointer;
            width: auto;
        }

        #execute-btn {
            background-color: var(--blue-accent);
        }

        #reset-btn {
            background-color: var(--grey-button);
        }

        #execute-btn:hover,
        #reset-btn:hover {
            opacity: 0.9;
        }

        #output-area {
            flex-grow: 1;
            padding: 10px;
            font-size: 15px;
            overflow-y: auto;
            background-color: #202123;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .results-container h2 {
            margin-top: 0;
            border-bottom: 1px solid var(--grey-border);
            padding-bottom: 8px;
            font-size: 1.2em;
        }

        .results-container>p {
            font-size: 0.85em;
            color: #ccc;
            margin-bottom: 15px;
        }

        .error-card {
            background-color: #3a3d41;
            border-left: 5px solid var(--yellow-warning);
            padding: 12px 18px;
            margin-bottom: 12px;
            border-radius: 4px;
        }

        .card-header {
            font-weight: bold;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1em;
        }

        .card-icon {
            width: 12px;
            height: 12px;
            background-color: var(--yellow-warning);
            flex-shrink: 0;
        }

        .card-header-text {
            font-family: monospace;
            background-color: #2b2b2b;
            padding: 2px 6px;
            border-radius: 3px;
            color: #E0E0E0;
        }

        .error-card>div:not(:first-child) {
            margin-top: 12px;
        }

        .error-summary {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .error-explanation {
            font-size: 0.9em;
            line-height: 1.5;
            color: #ddd;
        }

        .error-explanation code {
            background-color: #555;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
            color: #f0f0f0;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chat-bubble {
            display: flex;
            align-items: center;
            max-width: 80%;
        }

        .chat-bubble .icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            flex-shrink: 0;
            
            -webkit-mask-image: url("data:image/svg+xml,%3csvg viewBox='670 200 96 96' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M734 230C734 238.837 726.837 246 718 246 709.163 246 702 238.837 702 230 702 221.163 709.163 214 718 214 726.837 214 734 221.163 734 230Z'/%3e%3cpath d='M750 282 750 266C750 263.6 748.8 261.2 746.8 259.6 742.4 256 736.8 253.6 731.2 252 727.2 250.8 722.8 250 718 250 713.6 250 709.2 250.8 704.8 252 699.2 253.6 693.6 256.4 689.2 259.6 687.2 261.2 686 263.6 686 266L686 282 750 282Z'/%3e%3c/svg%3e");
            mask-image: url("data:image/svg+xml,%3csvg viewBox='670 200 96 96' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M734 230C734 238.837 726.837 246 718 246 709.163 246 702 238.837 702 230 702 221.163 709.163 214 718 214 726.837 214 734 221.163 734 230Z'/%3e%3cpath d='M750 282 750 266C750 263.6 748.8 261.2 746.8 259.6 742.4 256 736.8 253.6 731.2 252 727.2 250.8 722.8 250 718 250 713.6 250 709.2 250.8 704.8 252 699.2 253.6 693.6 256.4 689.2 259.6 687.2 261.2 686 263.6 686 266L686 282 750 282Z'/%3e%3c/svg%3e");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            background-color: white; 
        }

        .chat-bubble .message {
            background-color: white;
            color: black;
            padding: 15px;
            border-radius: 15px;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .user-input-bubble {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .user-input-bubble .icon {
            background-color: var(--orange-accent); 
            margin-left: 10px;
            margin-right: 0;
        }

        #chat-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            margin-top: 10px;
        }

        #chat-input {
            background-color: #fff;
            color: #000;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            flex-grow: 1;
        }

        #chat-submit {
            padding: 8px 12px;
            border: none;
            background-color: var(--blue-accent);
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="panel left-panel">
            <textarea id="code-editor"># コードを入力してください
</textarea>
        </div>
        <div class="panel right-panel">
            <div class="button-container">
                <button id="execute-btn">実行</button>
                <button id="reset-btn">リセット</button>
            </div>
            <div id="output-area">
            </div>
        </div>
    </div>

    <script>
        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            mode: 'python',
            theme: 'material-darker',
            lineNumbers: true,
            indentUnit: 4,
            autoCloseBrackets: true
        });

        const executeBtn = document.getElementById('execute-btn');
        const resetBtn = document.getElementById('reset-btn');
        const outputArea = document.getElementById('output-area');

        executeBtn.addEventListener('click', () => checkAndRunCode(editor.getValue()));

        resetBtn.addEventListener('click', () => {
            outputArea.innerHTML = '';
            editor.setValue('# コードを入力してください\n');
        });

        const PYTHON_RESERVED_WORDS = ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'];
        const COMMON_FUNCTIONS = ['print', 'range', 'input', 'int', 'float', 'str', 'random'];

        const errorCatalog = {
            'MISSING_IMPORT': {
                summary: "モジュールをインポート（import）する必要があります。",
                explanation: "<code>random.randint()</code> のような便利な機能を使うには、コードの最初に <code>import random</code> と書くことで、その機能の部品箱（モジュール）を読み込む必要があります。"
            },
            'FULL_WIDTH_CHAR': {
                summary: "全角の文字や記号が使われています。",
                explanation: "プログラミングのコードは、すべて半角の英数字と記号で記述するのがルールです。全角スペース、全角カッコ、全角コロンなどが紛れ込んでいないか確認しましょう。"
            },
            'INDENT_NOT_MULTIPLE_OF_4': {
                summary: "インデントのスペースの数が正しくありません。",
                explanation: "Pythonでは、インデント（字下げ）は半角スペース4つを1単位とします。タブや、1〜3個などの半端な数のスペースが使われていないか確認してください。"
            },
            'WRONG_INDENT_AFTER_COLON': {
                summary: "インデントが正しくありません。",
                explanation: "<code>if</code>, <code>for</code>, <code>while</code> など、行の末尾がコロン「:」で終わる行の次の行は、必ずインデントを1段階深く（スペース4つ分）する必要があります。"
            },
            'SPELLING_ERROR': {
                summary: "「{{found}}」の大文字・小文字またはスペルが間違っています。",
                explanation: "Pythonの基本的な命令（キーワードや組み込み関数）は、すべて小文字で書くルールです。正しくは <code>{{expected}}</code> です。"
            },
            'MISSING_COLON': {
                summary: "行の末尾に必要なコロン「:」がありません。",
                explanation: "<code>if</code>, <code>elif</code>, <code>else</code>, <code>for</code>, <code>while</code> のような、次の行からコードブロックが始まる行の末尾には、必ずコロン <code>:</code> が必要です。"
            },
            'ASSIGN_IN_IF': {
                summary: "条件式での比較の仕方が間違っています。",
                explanation: "「もしAとBが等しいなら」という比較をしたいときは <code>==</code>（イコール2つ）を使います。<code>=</code>（イコール1つ）は、変数に値を代入するための記号です。"
            },
            'UNEXPECTED_ELIF': {
                summary: "<code>elif</code> の位置が正しくありません。",
                explanation: "<code>elif</code> は、同じインデント（階層）にある <code>if</code> または別の <code>elif</code> の直後に書く必要があります。単独で使ったり、関係ないコードを間に挟むことはできません。"
            },
            'ELSE_IF_SYNTAX': {
                summary: "<code>else if</code> の書き方が間違っています。",
                explanation: "Pythonでは、<code>else if</code> ではなく <code>elif</code> と書きます。"
            },
            'UNEXPECTED_ELSE': {
                summary: "<code>else</code> の位置が正しくありません。",
                explanation: "<code>else</code> は、同じインデント（階層）にある <code>if</code> または <code>elif</code> の直後に書く必要があります。<code>else</code> の前に、ペアになる <code>if</code>文があるか確認してください。"
            },
            'FOR_SYNTAX_IN': {
                summary: "<code>for</code>文の書き方が間違っています。",
                explanation: "Pythonの <code>for</code> 文には、<code>in</code> が必要です。回数を指定して繰り返す場合は <code>for i in range(5):</code> のように書きます。"
            },
            'PRINT_NO_QUOTES': {
                summary: "文字列をクォートで囲む必要があります。",
                explanation: "文字や文章（文字列）を画面に表示するには、その文字列をシングルクォート <code>' '</code> かダブルクォート <code>\" \"</code> で囲む必要があります。もし変数の値を表示したい場合は、その変数がこの行より前で定義されているか確認してください。"
            },
            'VAR_STARTS_WITH_NUMBER': {
                summary: "変数名の付け方が間違っています。",
                explanation: "変数名は、数字から始めることはできません。アルファベットかアンダースコア <code>_</code> から始める必要があります。"
            },
            'VAR_IS_RESERVED': {
                summary: "予約語を変数名として使っています。",
                explanation: "<code>{{keyword}}</code> は、Pythonが特別な意味を持つ言葉（予約語）として使っているため、変数名にすることはできません。別の名前に変更してください。"
            },
            'LIST_ACCESS_WITH_PARENS': {
                summary: "リストの要素へのアクセス方法が間違っています。",
                explanation: "リストの特定の要素を取り出すには、丸括弧 <code>()</code> ではなく、角括弧 <code>[]</code> を使います。例えば、リストの最初の要素は <code>my_list[0]</code> のように書きます。"
            },
            'UNCLOSED_PARENTHESIS': {
                summary: "カッコやクォートの使い方が間違っています。",
                explanation: "開きカッコ `(` を使ったら、必ず対応する閉じカッコ `)` が必要です。また、表示したい文字や文章（文字列）は、<code>'</code> または `\"` で囲み、そのクォートもきちんと閉じる必要があります。<br><br><b>正しい例:</b><br><code>print(\"こんにちは\")</code><br><code>print(123)</code>"
            },
            'INVALID_OPERATOR': {
                summary: "Pythonでは使えない記号が使われています。",
                explanation: "他のプログラミング言語で使われる <code>{{operator}}</code> は、Pythonでは使えません。代わりにキーワード <code>{{py_equivalent}}</code> を使ってください。"
            },
            'FORMAT_ARG_MISMATCH': {
                summary: "<code>.format()</code> の引数の数が合っていません。",
                explanation: "文章に埋め込みたい場所 <code>{}</code> の数と、<code>.format()</code> のカッコの中に入れる変数の数が一致しているか確認してください。<code>{}</code> が {{placeholder_count}}個に対し、変数は {{arg_count}}個です。"
            },
            'TYPE_ERROR_CONCAT': {
                summary: "文字列と数値を <code>+</code> で直接つなぐことはできません。",
                explanation: "数値を文字列と一緒に表示したい場合は、数値を <code>str()</code> 関数で囲んで文字列に変換するか、<code>.format()</code> を使って埋め込む必要があります。<br><b>修正例1:</b> <code>print(\"スコアは \" + str(100))</code><br><b>修正例2:</b> <code>print(\"スコアは {}\".format(100))</code>"
            }
        };

        // --- ▼▼▼ 変更箇所 ▼▼▼ ---
        /**
         * 文字列リテラルを考慮して、行からコメント部分(#以降)を除去する関数
         * @param {string} line - 処理対象のコード行
         * @returns {string} コメントが除去されたコード部分
         */
        function stripComment(line) {
            let in_string = null;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (in_string) {
                    if (char === in_string && (i === 0 || line[i - 1] !== '\\')) {
                        in_string = null;
                    }
                } else {
                    if (char === "'" || char === '"') {
                        in_string = char;
                    } 
                    else if (char === '#') {
                        return line.substring(0, i);
                    }
                }
            }
            return line;
        }
        // --- ▲▲▲ 変更箇所 ▲▲▲ ---

        function formatErrorMessage(error) {
            const template = errorCatalog[error.type];
            if (!template) return {
                summary: '不明なエラー',
                explanation: JSON.stringify(error)
            };
            let summary = template.summary;
            let explanation = template.explanation;
            if (error.context) {
                for (const key in error.context) {
                    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
                    summary = summary.replace(regex, error.context[key]);
                    explanation = explanation.replace(regex, `<code>${error.context[key]}</code>`);
                }
            }
            return {
                summary,
                explanation
            };
        }

        function checkAndRunCode(code) {
            outputArea.innerHTML = '';
            const lines = code.split('\n');
            let errors = [];
            let definedVariables = new Set(COMMON_FUNCTIONS);

            if (code.match(/random\./) && !code.match(/^\s*import\s+random/m)) {
                errors.push({
                    line: 1,
                    type: 'MISSING_IMPORT'
                });
            }
            let structure = {
                ifs: []
            };
            let indentLevels = [];
            lines.forEach((line, index) => {
                const lineNumber = index + 1;
                const trimmedLine = line.trim();
                const currentIndent = line.match(/^\s*/)[0].length;
                indentLevels[index] = currentIndent;
                if (trimmedLine.length === 0 || trimmedLine.startsWith('#')) return;

                // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                const codePart = stripComment(line);
                const codeWithoutStrings = codePart.replace(/(['"]).*?\1/g, "''");
                // --- ▲▲▲ 変更箇所 ▲▲▲ ---

                if (/[！-～]/.test(codeWithoutStrings)) {
                    errors.push({
                        line: lineNumber,
                        type: 'FULL_WIDTH_CHAR'
                    });
                }

                if (currentIndent % 4 !== 0) {
                    errors.push({
                        line: lineNumber,
                        type: 'INDENT_NOT_MULTIPLE_OF_4'
                    });
                }

                const prevLine = index > 0 ? lines[index - 1].trim() : '';
                if (prevLine.endsWith(':') && currentIndent <= indentLevels[index - 1]) {
                    errors.push({
                        line: lineNumber,
                        type: 'WRONG_INDENT_AFTER_COLON'
                    });
                }

                let match;
                const firstWord = trimmedLine.split(/[\s(:\[=]/)[0];

                const checkColon = (keyword) => {
                    if (!stripComment(trimmedLine).trim().endsWith(':')) errors.push({
                        line: lineNumber,
                        type: 'MISSING_COLON',
                        context: {
                            keyword
                        }
                    })
                };

                const checkSpelling = (keyword, targetWord) => {
                    const wordToCheck = targetWord || firstWord;
                    if (wordToCheck && wordToCheck !== keyword && wordToCheck.toLowerCase() === keyword) {
                        errors.push({
                            line: lineNumber,
                            type: 'SPELLING_ERROR',
                            context: {
                                found: wordToCheck,
                                expected: keyword
                            }
                        });
                    }
                };

                if ((match = trimmedLine.match(/^(\w+)\s*=/))) definedVariables.add(match[1]);
                if ((match = trimmedLine.match(/^for\s+(\w+)\s+in/))) definedVariables.add(match[1]);
                
                const ifElifStaticMatch = trimmedLine.match(/^(if|elif)[\s(]/);
                if (ifElifStaticMatch) {
                    const keyword = ifElifStaticMatch[1];
                    checkSpelling(keyword);
                    checkColon(keyword);

                    const conditionPart = trimmedLine.substring(trimmedLine.indexOf(keyword) + keyword.length, trimmedLine.lastIndexOf(':')).trim();
                    if (conditionPart.includes('=') && !conditionPart.includes('==') && !conditionPart.includes('!=') && !conditionPart.includes('<=') && !conditionPart.includes('>=')) {
                        errors.push({ line: lineNumber, type: 'ASSIGN_IN_IF' });
                    }
                    
                    if (keyword === 'elif' && (structure.ifs.length === 0 || structure.ifs[structure.ifs.length - 1].indent !== currentIndent)) {
                        errors.push({ line: lineNumber, type: 'UNEXPECTED_ELIF' });
                    }
                    if (keyword === 'if') {
                        structure.ifs = structure.ifs.filter(s => s.indent < currentIndent);
                    }
                    structure.ifs.push({ line: lineNumber, indent: currentIndent });
                } else if (trimmedLine.startsWith('else:')) {
                    checkSpelling('else');
                    if (structure.ifs.length === 0 || structure.ifs[structure.ifs.length - 1].indent !== currentIndent) {
                        errors.push({
                            line: lineNumber,
                            type: 'UNEXPECTED_ELSE'
                        });
                    }
                    structure.ifs = [];
                } else if (trimmedLine.startsWith('else if')) {
                    errors.push({
                        line: lineNumber,
                        type: 'ELSE_IF_SYNTAX'
                    });
                } else if (trimmedLine.startsWith('for ')) {
                    checkSpelling('for');
                    checkColon('for');
                    if (!trimmedLine.includes(' in ')) errors.push({
                        line: lineNumber,
                        type: 'FOR_SYNTAX_IN'
                    });
                } else if (trimmedLine.startsWith('while ')) {
                    checkSpelling('while');
                    checkColon('while');
                // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                } else if (stripComment(trimmedLine).trim().toLowerCase().startsWith('print')) {
                    checkSpelling('print');
                    const lineWithoutComment = stripComment(trimmedLine).trim();
                    // 正規表現をより堅牢なものに変更
                    const content = lineWithoutComment.match(/^print\s*\((.*)\)\s*$/i);
                    if (content) {
                        const arg = content[1].trim();
                        if (arg) {
                            const isKnownVar = definedVariables.has(arg.match(/^(\w+)/)?.[1]);
                            const isString = /^(['"]).*\1$/.test(arg);
                            const isNumber = !isNaN(parseFloat(arg)) && isFinite(arg);
                            const isExpression = /[\+\-\*\/%,\[\]()]/.test(arg);
                            if (!isKnownVar && !isString && !isNumber && !isExpression && /[a-zA-Z]/.test(arg)) {
                                errors.push({
                                    line: lineNumber,
                                    type: 'PRINT_NO_QUOTES'
                                });
                            }
                        }
                    } else {
                        errors.push({
                            line: lineNumber,
                            type: 'UNCLOSED_PARENTHESIS'
                        });
                    }
                // --- ▲▲▲ 変更箇所 ▲▲▲ ---
                } else if ((match = trimmedLine.match(/^(\w+)\s*=/))) {
                    const varName = match[1];
                    if (!isNaN(parseInt(varName[0]))) errors.push({
                        line: lineNumber,
                        type: 'VAR_STARTS_WITH_NUMBER'
                    });
                    if (PYTHON_RESERVED_WORDS.includes(varName)) errors.push({
                        line: lineNumber,
                        type: 'VAR_IS_RESERVED',
                        context: {
                            keyword: varName
                        }
                    });
                } else if (trimmedLine.match(/\w+\(.*\)/) && trimmedLine.match(/^\w+\s*\(\s*\d+\s*\)$/)) {
                    errors.push({
                        line: lineNumber,
                        type: 'LIST_ACCESS_WITH_PARENS'
                    });
                }

                if (trimmedLine.includes('&&')) errors.push({
                    line: lineNumber,
                    type: 'INVALID_OPERATOR',
                    context: {
                        operator: '&&',
                        py_equivalent: 'and'
                    }
                });
                if (trimmedLine.includes('||')) errors.push({
                    line: lineNumber,
                    type: 'INVALID_OPERATOR',
                    context: {
                        operator: '||',
                        py_equivalent: 'or'
                    }
                });
                if (trimmedLine.includes('.format(')) {
                    const placeholderMatch = trimmedLine.match(/\{(?!\d)/g);
                    if (placeholderMatch) {
                        const placeholderCount = placeholderMatch.length;
                        const formatContentMatch = trimmedLine.match(/\.format\((.*)\)/);
                        if (formatContentMatch) {
                            const argsStr = formatContentMatch[1];
                            const argCount = argsStr.trim() === '' ? 0 : (argsStr.split(',').length);
                            if (placeholderCount !== argCount) {
                                errors.push({
                                    line: lineNumber,
                                    type: 'FORMAT_ARG_MISMATCH',
                                    context: {
                                        placeholder_count: placeholderCount,
                                        arg_count: argCount
                                    }
                                });
                            }
                        }
                    }
                }
                if (trimmedLine.includes('+') && trimmedLine.match(/(['"].*['"]\s*\+\s*\d+)|(\d+\s*\+\s*['"].*['"])/)) {
                    errors.push({
                        line: lineNumber,
                        type: 'TYPE_ERROR_CONCAT'
                    });
                }
                COMMON_FUNCTIONS.forEach(func => {
                    const regex = new RegExp(`\\b(${func})\\b`, 'i');
                    const match = trimmedLine.match(regex);
                    if (match && match[1] !== func) checkSpelling(func, match[1]);
                });
            });


            if (errors.length > 0) {
                displayStaticErrors(errors, lines);
            } else {
                simulateExecution(code).catch(e => addChatBubble('error', `${e.message}`));
            }
        }

        function displayStaticErrors(errors, lines) {
            outputArea.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'results-container';
            container.innerHTML = `<h2>コードのチェック結果</h2><p>以下の間違いが見つかりました。修正してもう一度「実行」してみましょう。</p>`;
            const uniqueErrors = [...new Map(errors.map(item => [`${item.line}-${item.type}`, item])).values()];
            uniqueErrors.sort((a, b) => a.line - b.line);
            const errorGroups = {};
            uniqueErrors.forEach(err => {
                if (!errorGroups[err.line]) errorGroups[err.line] = [];
                errorGroups[err.line].push(err);
            });
            for (const lineNumber in errorGroups) {
                const card = document.createElement('div');
                card.className = 'error-card';
                const header = document.createElement('div');
                header.className = 'card-header';
                const trimmedCode = lines[lineNumber - 1].trim();
                header.innerHTML = `<div class="card-icon"></div> <div>${lineNumber}行目: <span class="card-header-text">${trimmedCode}</span></div>`;
                card.appendChild(header);
                errorGroups[lineNumber].forEach(err => {
                    const {
                        summary,
                        explanation
                    } = formatErrorMessage(err);
                    const errorContentWrapper = document.createElement('div');
                    errorContentWrapper.innerHTML = `<div class="error-summary">${summary}</div><div class="error-explanation">${explanation}</div>`;
                    card.appendChild(errorContentWrapper);
                });
                container.appendChild(card);
            }
            outputArea.appendChild(container);
        }

        function robustSplitArgs(argsStr) {
            if (argsStr.trim() === '') return [];
            const args = [];
            let currentArg = '';
            let parenDepth = 0;
            let bracketDepth = 0;
            let braceDepth = 0;
            let inString = null;

            for (let i = 0; i < argsStr.length; i++) {
                const char = argsStr[i];
                if (inString) {
                    if (char === inString && (i === 0 || argsStr[i - 1] !== '\\')) {
                        inString = null;
                    }
                } else {
                    if (char === "'" || char === '"') inString = char;
                    else if (char === '(') parenDepth++;
                    else if (char === ')') parenDepth--;
                    else if (char === '[') bracketDepth++;
                    else if (char === ']') bracketDepth--;
                    else if (char === '{') braceDepth++;
                    else if (char === '}') braceDepth--;
                    else if (char === ',' && parenDepth === 0 && bracketDepth === 0 && braceDepth === 0) {
                        args.push(currentArg.trim());
                        currentArg = '';
                        continue;
                    }
                }
                currentArg += char;
            }
            args.push(currentArg.trim());
            return args.filter(arg => arg);
        }

        function parsePrintArgs(fullArgsStr) {
            let args = [];
            let end = null;
            let mainArgsStr = fullArgsStr;

            const endMatch = fullArgsStr.match(/(,?\s*end\s*=\s*(['"](?:\\.|[^'"])*['"]|'(?:\\.|[^'])*'))/);
            if (endMatch) {
                const endArgStr = endMatch[2];
                try {
                    end = JSON.parse(endArgStr.replace(/'/g, '"'));
                } catch {
                    end = endArgStr.slice(1, -1);
                }
                mainArgsStr = fullArgsStr.substring(0, endMatch.index).trim();
            }

            if (mainArgsStr) {
                args = robustSplitArgs(mainArgsStr);
            }
            return {
                args,
                end
            };
        }

        async function simulateExecution(code) {
            outputArea.innerHTML = '<div class="chat-container"></div>';
            const lines = code.split('\n');
            const state = {
                variables: {
                    'random': {
                        randint: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a
                    }
                },
                linePointer: 0,
                blockStack: [],
                outputBuffer: ''
            };
            const MAX_ITERATIONS = 2000;
            let iterationCount = 0;

            const flushOutputBuffer = () => {
                if (state.outputBuffer) {
                    addChatBubble('system', state.outputBuffer);
                    state.outputBuffer = '';
                }
            };

            while (state.linePointer < lines.length) {
                if (++iterationCount > MAX_ITERATIONS) throw new Error("実行時エラー: 実行が長すぎるため停止しました。whileループの条件が永遠に偽にならないなど、無限ループになっている可能性があります。");

                const lineIndex = state.linePointer;
                const line = lines[lineIndex];
                const indent = line.match(/^\s*/)[0].length;
                const trimmedLine = line.trim();

                const lineWithoutComment = stripComment(trimmedLine).trim();
                const isPrintLine = lineWithoutComment.toLowerCase().startsWith('print');

                if (!isPrintLine && state.outputBuffer && !state.outputBuffer.endsWith('\n')) {
                    flushOutputBuffer();
                }

                while (state.blockStack.length > 0 && indent <= state.blockStack[state.blockStack.length - 1].indent) {
                    const endedBlock = state.blockStack.pop();
                    if ((endedBlock.type === 'for' || endedBlock.type === 'while') && endedBlock.line === lineIndex) {} else if (endedBlock.type === 'for' || endedBlock.type === 'while') {
                        state.linePointer = endedBlock.line;
                        break;
                    }
                }
                if (state.linePointer !== lineIndex) continue;

                if (trimmedLine.length === 0 || trimmedLine.startsWith('#')) {
                    state.linePointer++;
                    continue;
                }

                const currentBlock = state.blockStack.length > 0 ? state.blockStack[state.blockStack.length - 1] : null;
                if (currentBlock && !currentBlock.execute && !(trimmedLine.match(/^(elif|else)[\s:]/))) {
                    state.linePointer++;
                    continue;
                }

                state.linePointer++;
                let match;
                
                if (isPrintLine) {
                    const contentMatch = lineWithoutComment.match(/^print\s*\((.*)\)\s*$/i);
                    if (contentMatch) {
                        const {
                            args,
                            end
                        } = parsePrintArgs(contentMatch[1] || '');
                        const evaluatedArgs = args.map(arg => evaluateExpression(arg, state));
                        state.outputBuffer += evaluatedArgs.join(' ');
                        state.outputBuffer += (end !== null) ? end : '\n';
                        if (state.outputBuffer.endsWith('\n')) {
                            addChatBubble('system', state.outputBuffer.slice(0, -1));
                            state.outputBuffer = '';
                        }
                    }
                } else {
                    let ifElifMatch;
                    if ((ifElifMatch = trimmedLine.match(/^(if|elif)\s*(?:\((.*)\)|(.*))\s*:/))) {
                        const keyword = ifElifMatch[1];
                        // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                        const conditionWithComment = ifElifMatch[2] ?? ifElifMatch[3];
                        const condition = stripComment(conditionWithComment).trim();
                        // --- ▲▲▲ 変更箇所 ▲▲▲ ---

                        if (keyword === 'if') {
                            const result = evaluateExpression(condition, state);
                            state.blockStack.push({ type: 'if', line: lineIndex, indent: indent, execute: result, chainSuccess: result });
                        } else { // elif
                            const prevBlock = state.blockStack.pop();
                            if (!prevBlock || (prevBlock.type !== 'if' && prevBlock.type !== 'elif')) throw new Error(`実行時エラー: elifはif/elifの後に来る必要があります。`);
                            const execute = !prevBlock.chainSuccess && evaluateExpression(condition, state);
                            state.blockStack.push({ ...prevBlock, type: 'elif', execute: execute, chainSuccess: prevBlock.chainSuccess || execute });
                        }
                    } else if (trimmedLine.startsWith('else:')) {
                        const prevBlock = state.blockStack.pop();
                        if (!prevBlock || (prevBlock.type !== 'if' && prevBlock.type !== 'elif')) throw new Error(`実行時エラー: elseはif/elifの後に来る必要があります。`);
                        state.blockStack.push({ ...prevBlock,
                            type: 'else',
                            execute: !prevBlock.chainSuccess
                        });
                    } else if ((match = trimmedLine.match(/^for\s+(\w+)\s+in\s+range\((.*)\):/))) {
                        state.linePointer = lineIndex;
                        const loopVar = match[1];
                        // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                        const rangeArgsStr = stripComment(match[2]).trim();
                        // --- ▲▲▲ 変更箇所 ▲▲▲ ---
                        const rangeArgs = robustSplitArgs(rangeArgsStr).map(a => evaluateExpression(a, state));
                        const [start, end, step] = rangeArgs.length === 1 ? [0, rangeArgs[0], 1] : rangeArgs.length === 2 ? [rangeArgs[0], rangeArgs[1], 1] : rangeArgs;
                        let loopBlock = (currentBlock && currentBlock.type === 'for' && currentBlock.line === lineIndex) ? currentBlock : null;

                        if (loopBlock) {
                            loopBlock.loopState.current += loopBlock.loopState.step;
                        } else {
                            loopBlock = {
                                type: 'for',
                                line: lineIndex,
                                indent: indent,
                                execute: true,
                                loopVar,
                                loopState: {
                                    current: start,
                                    end: end,
                                    step: step
                                }
                            };
                            state.blockStack.push(loopBlock);
                        }
                        if ((step > 0 && loopBlock.loopState.current < end) || (step < 0 && loopBlock.loopState.current > end)) {
                            state.variables[loopVar] = loopBlock.loopState.current;
                            state.linePointer++;
                        } else {
                            state.blockStack.pop();
                            state.linePointer = findBlockEnd(lines, lineIndex);
                        }
                    } else if ((match = trimmedLine.match(/^while\s+(.+?):/))) {
                        state.linePointer = lineIndex;
                        // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                        const condition = stripComment(match[1]).trim();
                        // --- ▲▲▲ 変更箇所 ▲▲▲ ---
                        if (!currentBlock || currentBlock.type !== 'while' || currentBlock.line !== lineIndex) {
                            state.blockStack.push({
                                type: 'while',
                                line: lineIndex,
                                indent: indent,
                                execute: true,
                                condition: condition
                            });
                        }
                        if (evaluateExpression(condition, state)) {
                            state.linePointer++;
                        } else {
                            state.blockStack.pop();
                            state.linePointer = findBlockEnd(lines, lineIndex);
                        }
                    } else if (trimmedLine.includes('input(')) {
                        flushOutputBuffer();
                        // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                        const expression = stripComment(trimmedLine.split('=')[1]).trim();
                        // --- ▲▲▲ 変更箇所 ▲▲▲ ---
                        const varName = trimmedLine.split('=')[0].trim();
                        const prompt = expression.match(/input\((.*)\)/) ? evaluateExpression(expression.match(/input\((.*)\)/)[1], state) : '';
                        state.variables[varName] = await handleInput(prompt);
                    } else if (trimmedLine.includes('=')) {
                        const parts = trimmedLine.split('=').map(p => p.trim());
                        if (parts.length > 1) {
                            const target = parts[0];
                            // --- ▼▼▼ 変更箇所 ▼▼▼ ---
                            const expressionWithComment = parts.slice(1).join('=');
                            const expressionToEvaluate = stripComment(expressionWithComment).trim();
                            const value = evaluateExpression(expressionToEvaluate, state);
                            // --- ▲▲▲ 変更箇所 ▲▲▲ ---

                            if ((match = target.match(/^(\w+)\[(.*)\]$/))) {
                                const listName = match[1];
                                const index = evaluateExpression(match[2], state);
                                if (!Array.isArray(state.variables[listName])) throw new Error(`実行時エラー (TypeError): '${listName}' はリストではないため、[]を使った要素の代入はできません。`);
                                const list = state.variables[listName];
                                if (index < 0 || index >= list.length) throw new Error(`実行時エラー (IndexError): リストの範囲を超えて代入しようとしました。このリストの大きさは ${list.length} ですが、${index} 番目に代入しようとしています。`);
                                state.variables[listName][index] = value;
                            } else {
                                state.variables[target] = value;
                            }
                        }
                    }
                }
            }
            flushOutputBuffer();
        }

        function findBlockEnd(lines, startLineIndex) {
            const startIndent = lines[startLineIndex].match(/^\s*/)[0].length;
            for (let i = startLineIndex + 1; i < lines.length; i++) {
                if (lines[i].trim() !== '' && lines[i].match(/^\s*/)[0].length <= startIndent) return i;
            }
            return lines.length;
        }

        function evaluateExpression(expr, state) {
            if (expr.trim() === '') return '';
            expr = expr.trim();
            let match;

            if (expr.includes('.format(')) {
                const parts = expr.split('.format(');
                if (parts.length > 1) {
                    const templateExpr = parts[0];
                    const argsStr = parts.slice(1).join('.format(').slice(0, -1);
                    const template = evaluateExpression(templateExpr, state);
                    if (typeof template !== 'string') throw new Error(`実行時エラー (AttributeError): '${typeof template}' 型のオブジェクトに '.format' 属性はありません。`);
                    const evaluatedArgs = robustSplitArgs(argsStr).map(arg => evaluateExpression(arg, state));
                    let argIndex = 0;
                    return template.replace(/{(\d*)}/g, (match, indexStr) => {
                        const index = indexStr === '' ? argIndex++ : parseInt(indexStr);
                        if (index >= evaluatedArgs.length) throw new Error(`実行時エラー (IndexError): .format() の引数が足りません。`);
                        return evaluatedArgs[index];
                    });
                }
            }

            if ((match = expr.match(/^(?:int|float)\((.*)\)$/))) {
                const arg = evaluateExpression(match[1], state);
                const result = expr.startsWith('int') ? parseInt(arg) : parseFloat(arg);
                if (isNaN(result) && typeof arg === 'string') throw new Error(`実行時エラー (ValueError): 文字列 "${arg}" は数値に変換できません。`);
                return result;
            }
            if ((match = expr.match(/^str\((.*)\)$/))) {
                return String(evaluateExpression(match[1], state));
            }
            if ((match = expr.match(/^(\w+)\[(.*)\]$/))) {
                const listName = match[1];
                const index = evaluateExpression(match[2], state);
                const list = state.variables[listName];
                if (!Array.isArray(list)) throw new Error(`実行時エラー (TypeError): '${listName}' はリストではないため、[]を使った要素の取得はできません。`);
                if (index < 0 || index >= list.length) throw new Error(`実行時エラー (IndexError): リストの範囲を超えてアクセスしようとしました。このリストの大きさは ${list.length} ですが、${index} 番目にアクセスしようとしています。`);
            }

            try {
                const sanitizedExpr = expr.replace(/\s+and\s+/g, ' && ').replace(/\s+or\s+/g, ' || ').replace(/\bnot\s+/g, '!');
                const code = `const { ${Object.keys(state.variables).join(', ')} } = state.variables; return ${sanitizedExpr};`;
                return new Function('state', code)(state);
            } catch (e) {
                if (e.message.startsWith('実行時エラー')) throw e;
                if (e instanceof ReferenceError) {
                    const varName = e.message.match(/'([^']*)'|(\w+)\s+is not defined/)?.[1] || e.message.split(' ')[0];
                    throw new Error(`実行時エラー (NameError): 変数 '${varName}' が使われる前に、値が代入（定義）されていません。`);
                }
                if (e instanceof TypeError) {
                    if (e.message.includes("is not a function")) throw new Error(`実行時エラー (TypeError): ${e.message.split(' ')[0]} は関数ではありません。カッコ () をつける場所や、スペルが間違っている可能性があります。`);
                    throw new Error(`実行時エラー (TypeError): 文字列と数値など、異なる種類のデータを計算したり比較したりすることはできません。\n・もし数字を入力したつもりなら、input()をint()で囲んでみてください。(例: int(input()))\n・もし数値を文字列と連結したいなら、str()で囲んでみてください。(例: "点数:" + str(100))`);
                }
                throw new Error(`実行時エラー: 式の評価中に不明なエラーが発生しました: ${expr}`);
            }
        }

        function handleInput(prompt) {
            return new Promise(resolve => {
                if (prompt) addChatBubble('system', prompt);
                const iC = document.createElement('div');
                iC.id = 'chat-input-container';
                const iE = document.createElement('input');
                iE.id = 'chat-input';
                iE.type = 'text';
                iE.placeholder = 'ここに入力してEnter';
                const sB = document.createElement('button');
                sB.id = 'chat-submit';
                sB.textContent = '送信';
                const sA = () => {
                    const uI = iE.value;
                    iC.remove();
                    addChatBubble('user', uI);
                    resolve(uI);
                };
                iE.addEventListener('keypress', e => {
                    if (e.key === 'Enter') sA();
                });
                sB.addEventListener('click', sA);
                iC.appendChild(iE);
                iC.appendChild(sB);
                outputArea.querySelector('.chat-container').appendChild(iC);
                iE.focus();
            });
        }

        function addChatBubble(type, text) {
            const cC = outputArea.querySelector('.chat-container');
            if (!cC) return;
            const b = document.createElement('div');
            b.className = 'chat-bubble';
            if (type === 'user') b.classList.add('user-input-bubble');
            const i = document.createElement('div');
            i.className = 'icon';
            const m = document.createElement('div');
            m.className = 'message';
            m.textContent = text;
            if (type === 'error') {
                m.style.backgroundColor = 'var(--red-error)';
                m.style.color = 'white';
            }
            b.appendChild(i);
            b.appendChild(m);
            cC.appendChild(b);
            outputArea.scrollTop = outputArea.scrollHeight;
        }
    </script>

</body>

</html>
