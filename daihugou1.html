<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オンライン大富豪 (シンプル版)</title>
    <style>
        /* --- 基本スタイル --- */
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #0a4a1b;
            color: white;
            text-align: center;
            padding: 10px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .hidden {
            display: none !important;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            margin: 5px;
            background-color: #f0c14b;
            color: #111;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #e0b03b;
        }

        button:active {
            transform: translateY(2px);
        }

        button:disabled {
            background-color: #aaa;
            color: #555;
            cursor: not-allowed;
        }

        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin: 5px;
        }

        h1,
        h2,
        h3 {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .container {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* --- 認証・ロビー画面 --- */
        #lobby-container {
            max-width: 600px;
        }

        #seats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .seat {
            background-color: #073514;
            border: 2px dashed #fff6;
            border-radius: 10px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .seat:hover:not(.taken) {
            background-color: #0c521e;
        }

        .seat.taken {
            background-color: #444;
            cursor: not-allowed;
        }

        .seat-number {
            font-size: 24px;
            font-weight: bold;
        }

        .seat-player {
            font-size: 14px;
            color: #ffdf7e;
        }

        /* --- ゲーム画面 --- */
        #game-board {
            width: 95vw;
            height: 95vh;
            position: relative;
            max-width: 1200px;
            max-height: 800px;
        }

        #table-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            height: 40%;
            border: 3px solid #f0c14b;
            border-radius: 50%;
            background-color: #062f12;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #field {
            display: flex;
            transform-style: preserve-3d;
        }

        #game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: left;
        }

        .player-pod {
            position: absolute;
            width: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
        }

        .player-pod.active-turn {
            box-shadow: 0 0 15px 5px #f0c14b;
        }

        .player-name {
            font-weight: bold;
        }

        .card-back-container {
            display: flex;
            justify-content: center;
            margin-top: 5px;
        }

        #player-pod-1 {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        #player-pod-2 {
            top: 50%;
            right: 2%;
            transform: translateY(-50%);
        }

        #player-pod-3 {
            top: 50%;
            left: 2%;
            transform: translateY(-50%);
        }

        #my-area {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #my-hand {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            padding: 0 50px;
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-status {
            font-size: 18px;
            font-weight: bold;
            margin: 0 20px;
        }

        #game-result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        #result-list {
            list-style: none;
            padding: 0;
            font-size: 24px;
        }

        #result-list li {
            margin: 10px 0;
        }

        /* --- トランプのスタイル --- */
        .card,
        .card-back {
            background-color: white;
            color: black;
            width: 70px;
            height: 98px;
            border-radius: 6px;
            border: 1px solid #aaa;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            font-size: 20px;
            font-weight: bold;
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #my-hand .card {
            margin-left: -40px;
            cursor: pointer;
        }

        #my-hand .card:hover {
            transform: translateY(-10px) rotate(2deg);
        }

        #my-hand .card.selected {
            transform: translateY(-25px);
            box-shadow: 0px 15px 20px rgba(255, 230, 150, 0.4);
        }

        #field .card {
            margin: -50px 0 0 -30px;
        }

        #field .card:first-child {
            margin: 0;
        }

        .card::before,
        .card::after {
            position: absolute;
            font-size: 14px;
            line-height: 1;
        }

        .card::before {
            top: 6px;
            left: 6px;
        }

        .card::after {
            bottom: 6px;
            right: 6px;
            transform: rotate(180deg);
        }

        .card.spade,
        .card.club {
            color: black;
        }

        .card.heart,
        .card.diamond {
            color: red;
        }

        .card.spade::before,
        .card.spade::after {
            content: '♠';
        }

        .card.heart::before,
        .card.heart::after {
            content: '♥';
        }

        .card.diamond::before,
        .card.diamond::after {
            content: '♦';
        }

        .card.club::before,
        .card.club::after {
            content: '♣';
        }

        .card-rank {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
        }

        .card.joker {
            background-color: #f0f0f0;
        }

        .card.joker .card-rank {
            font-size: 14px;
            letter-spacing: 1px;
        }

        .card-back {
            background-color: #b00020;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255, 255, 255, 0.1) 5px, rgba(255, 255, 255, 0.1) 10px);
            margin-left: -60px;
        }
    </style>
</head>

<body>

    <!-- 名前入力画面 -->
    <div id="login-container" class="container">
        <h1>オンライン大富豪 (シンプル版)</h1>
        <input type="text" id="player-name-input" placeholder="名前を入力してください">
        <button id="enter-lobby-button">ロビーに入る</button>
    </div>

    <!-- ロビー画面 -->
    <div id="lobby-container" class="container hidden">
        <h2>ロビー</h2>
        <p>ようこそ, <span id="user-name"></span> さん</p>
        <div>
            <input type="text" id="room-id-input" placeholder="ルームID">
            <button id="create-room-button">ルームを作成</button>
            <button id="join-room-button">ルームに参加</button>
        </div>
        <div id="seat-selection" class="hidden">
            <h3>席を選んでください</h3>
            <div id="seats-container"></div>
            <button id="start-game-button">ゲーム開始</button>
            <button id="leave-room-button">ルームを抜ける</button>
        </div>
    </div>

    <!-- ゲーム画面 -->
    <div id="game-container" class="hidden">
        <div id="game-board">
            <div id="game-info">
                <div>ルームID: <span id="room-id-display"></span></div>
                <div id="revolution-status"></div>
            </div>
            <div id="player-pod-1" class="player-pod hidden"></div>
            <div id="player-pod-2" class="player-pod hidden"></div>
            <div id="player-pod-3" class="player-pod hidden"></div>
            <div id="table-area">
                <div id="field"></div>
            </div>
            <div id="my-area">
                <div id="my-hand"></div>
                <div id="controls">
                    <button id="play-button">出す</button>
                    <div id="game-status"></div>
                    <button id="pass-button">パス</button>
                </div>
            </div>
        </div>
        <div id="game-result-overlay" class="hidden">
            <h2>ゲーム結果</h2>
            <ul id="result-list"></ul>
            <button id="next-game-button">次のゲームへ</button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // ====================================================================================
        // Firebaseの初期化
        // ====================================================================================
        const firebaseConfig = {
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            // ★★★ 注意：ここはあなたのFirebaseプロジェクトの設定情報に置き換えてください ★★★
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            apiKey: "AIzaSyBvSHSOVos2i4VJJHvw_Yf2c65ay6sy5gM",
            authDomain: "daihugou2025.firebaseapp.com",
            databaseURL: "https://daihugou2025-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "daihugou2025",
            storageBucket: "daihugou2025.firebasestorage.app",
            messagingSenderId: "413509348525",
            appId: "1:413509348525:web:54f06d865fdf4ba74e2a24",
            measurementId: "G-BR07RJP2H7"
        };
        // --- ここから下は変更しないでください ---

        try {
            firebase.initializeApp(firebaseConfig);
        } catch (e) {
            console.error("Firebase initialization error:", e);
            alert("Firebaseの初期化に失敗しました。firebaseConfigが正しく設定されているか確認してください。");
        }

        const db = firebase.database();

        // --- DOM要素 ---
        const loginContainer = document.getElementById('login-container');
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name-input');
        const enterLobbyButton = document.getElementById('enter-lobby-button');
        const userNameDisplay = document.getElementById('user-name');
        const createRoomButton = document.getElementById('create-room-button');
        const joinRoomButton = document.getElementById('join-room-button');
        const leaveRoomButton = document.getElementById('leave-room-button');
        const roomIdInput = document.getElementById('room-id-input');
        const seatSelection = document.getElementById('seat-selection');
        const seatsContainer = document.getElementById('seats-container');
        const startGameButton = document.getElementById('start-game-button');
        const roomIdDisplay = document.getElementById('room-id-display');
        const myHandDiv = document.getElementById('my-hand');
        const fieldDiv = document.getElementById('field');
        const playButton = document.getElementById('play-button');
        const passButton = document.getElementById('pass-button');
        const gameStatusDiv = document.getElementById('game-status');
        const revolutionStatusDiv = document.getElementById('revolution-status');
        const gameResultOverlay = document.getElementById('game-result-overlay');
        const resultList = document.getElementById('result-list');
        const nextGameButton = document.getElementById('next-game-button');

        // --- グローバル変数 ---
        let myPlayerInfo = null; // { id: '...', name: '...' }
        let currentRoomId = null;
        let mySeatId = null;
        let roomRef = null;
        const MAX_SEATS = 4;

        // --- プレイヤーのユニークIDを生成/取得 (認証の代わり) ---
        let myPlayerId = sessionStorage.getItem('daifugoPlayerId');
        if (!myPlayerId) {
            myPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('daifugoPlayerId', myPlayerId);
        }

        // ====================================================================================
        // ロビーロジック
        // ====================================================================================

        enterLobbyButton.addEventListener('click', () => {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                alert('名前を入力してください。');
                return;
            }
            myPlayerInfo = {
                id: myPlayerId,
                name: playerName
            };
            loginContainer.classList.add('hidden');
            lobbyContainer.classList.remove('hidden');
            userNameDisplay.textContent = myPlayerInfo.name;
        });

        // --- ルームを作成する処理 ---
        createRoomButton.addEventListener('click', async () => {
            const roomId = Math.random().toString(36).substr(2, 6).toUpperCase();
            roomRef = db.ref('rooms/' + roomId);
            try {
                // ★★★ 修正点: seats: {} を追加して、ルーム作成時に座席データを初期化します ★★★
                await roomRef.set({
                    gameState: 'waiting',
                    seats: {}, 
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                console.log(`ルーム ${roomId} の作成に成功しました。`);
                enterRoom(roomId);
            } catch (error) {
                // ★★★ 修正点: エラーハンドリングを追加 ★★★
                console.error("ルームの作成に失敗しました: ", error);
                alert("ルームの作成に失敗しました。Firebaseの設定やセキュリティルールを確認してください。");
            }
        });

        // --- ルームに参加する処理 ---
        joinRoomButton.addEventListener('click', () => {
            const roomId = roomIdInput.value.trim().toUpperCase();
            if (!roomId) {
                alert('ルームIDを入力してください。');
                return;
            }
            const ref = db.ref('rooms/' + roomId);
            ref.once('value', snapshot => {
                if (snapshot.exists()) {
                    console.log(`ルーム ${roomId} が見つかりました。参加します。`);
                    enterRoom(roomId);
                } else {
                    console.log(`ルーム ${roomId} が見つかりませんでした。`);
                    alert('ルームが見つかりません。IDが正しいか確認してください。');
                }
            }).catch(error => { // ★★★ 修正点: エラーハンドリングを追加 ★★★
                console.error("ルームの検索に失敗しました: ", error);
                alert("ルームの検索に失敗しました。Firebaseへの接続を確認してください。");
            });
        });

        // --- ルームから退出する処理 ---
        leaveRoomButton.addEventListener('click', async () => {
            if (mySeatId && currentRoomId) {
                const seatRef = db.ref(`rooms/${currentRoomId}/seats/${mySeatId}`);
                await seatRef.onDisconnect().cancel();
                await seatRef.remove();
            }
            if (roomRef) {
                roomRef.off();
            }
            currentRoomId = null;
            mySeatId = null;
            roomRef = null;
            seatSelection.classList.add('hidden');
            roomIdInput.parentElement.classList.remove('hidden');
        });

        // --- ルームに入室した後の共通処理 ---
        function enterRoom(roomId) {
            currentRoomId = roomId;
            roomRef = db.ref('rooms/' + roomId);
            roomIdInput.parentElement.classList.add('hidden');
            seatSelection.classList.remove('hidden');
            // ★★★ 修正点: データベースの監視が失敗した場合のエラーハンドリングを追加 ★★★
            roomRef.on('value', handleRoomUpdate, (error) => {
                console.error("ルームデータの監視に失敗しました: ", error);
                alert("ルームデータとの同期に失敗しました。ページを再読み込みしてください。");
                if (leaveRoomButton.onclick) leaveRoomButton.click();
            });
        }

        function handleRoomUpdate(snapshot) {
            if (!snapshot.exists()) {
                alert('ルームが解散しました。ロビーに戻ります。');
                window.location.reload();
                return;
            }
            const roomData = snapshot.val();
            const seats = roomData.seats || {};
            const myCurrentSeatEntry = Object.entries(seats).find(([_, player]) => player && player.id === myPlayerInfo.id);
            mySeatId = myCurrentSeatEntry ? myCurrentSeatEntry[0] : null;
            if (roomData.gameState === 'waiting') {
                lobbyContainer.classList.remove('hidden');
                gameContainer.classList.add('hidden');
                renderSeats(seats);
            } else if (roomData.gameState === 'playing' || roomData.gameState === 'finished') {
                if (mySeatId) {
                    lobbyContainer.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    updateGameUI(roomData);
                }
            }
        }

        function renderSeats(seats) {
            seatsContainer.innerHTML = '';
            const playerCount = Object.keys(seats).length;
            for (let i = 1; i <= MAX_SEATS; i++) {
                const seat = document.createElement('div');
                seat.className = 'seat';
                seat.dataset.seatId = i;
                const seatNumber = document.createElement('div');
                seatNumber.className = 'seat-number';
                seatNumber.textContent = `SEAT ${i}`;
                seat.appendChild(seatNumber);
                if (seats[i]) {
                    seat.classList.add('taken');
                    const seatPlayer = document.createElement('div');
                    seatPlayer.className = 'seat-player';
                    seatPlayer.textContent = seats[i].name;
                    seat.appendChild(seatPlayer);
                } else {
                    seat.onclick = () => takeSeat(i);
                }
                seatsContainer.appendChild(seat);
            }
            startGameButton.disabled = playerCount < 2 || !mySeatId;
        }

        async function takeSeat(seatId) {
            if (mySeatId && currentRoomId) {
                const oldSeatRef = db.ref(`rooms/${currentRoomId}/seats/${mySeatId}`);
                await oldSeatRef.onDisconnect().cancel();
                await oldSeatRef.remove();
            }
            const newSeatRef = db.ref(`rooms/${currentRoomId}/seats/${seatId}`);
            try {
                const result = await newSeatRef.transaction(currentData => {
                    if (currentData === null) {
                        return { id: myPlayerInfo.id, name: myPlayerInfo.name };
                    }
                    return;
                });
                if (result.committed) {
                    newSeatRef.onDisconnect().remove();
                } else {
                    alert('その席は他の人に取られました。');
                }
            } catch (error) {
                console.error("席の取得に失敗しました: ", error);
            }
        }

        startGameButton.addEventListener('click', () => {
            roomRef.once('value', snapshot => {
                const roomData = snapshot.val();
                const players = Object.entries(roomData.seats || {});
                if (players.length < 2) {
                    alert('2人以上いないと開始できません。');
                    return;
                }
                initializeNewGame(players);
            });
        });
        
        window.addEventListener('beforeunload', () => {
            if (mySeatId && currentRoomId) {
                db.ref(`rooms/${currentRoomId}/seats/${mySeatId}`).remove();
            }
        });

        // ====================================================================================
        // ゲームロジック
        // ====================================================================================
        function initializeNewGame(players) {
            const deck = createDeck();
            const hands = dealCards(deck, players.length);
            const playerHands = {};
            const playerInfo = {};
            const sortedPlayers = players.sort((a, b) => a[0] - b[0]);
            sortedPlayers.forEach(([seatId, player], index) => {
                playerHands[player.id] = hands[index];
                playerInfo[seatId] = { ...player, cardCount: hands[index].length };
            });
            let firstPlayerSeatId = sortedPlayers[0][0];
            for (const [playerId, hand] of Object.entries(playerHands)) {
                if (hand.some(card => card.suit === 'diamond' && card.rank === 3)) {
                    const player = sortedPlayers.find(p => p[1].id === playerId);
                    if (player) firstPlayerSeatId = player[0];
                    break;
                }
            }
            const newGameData = {
                hands: playerHands, playerInfo: playerInfo, field: [], lastPlay: null,
                currentTurnSeatId: firstPlayerSeatId, passCount: 0, isRevolution: false, winners: [],
            };
            roomRef.update({ gameState: 'playing', gameData: newGameData });
        }

        function createDeck() {
            const suits = ['spade', 'heart', 'diamond', 'club'];
            const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 1, 2];
            let deck = suits.flatMap(suit => ranks.map(rank => ({ suit, rank })));
            deck.push({ suit: 'joker', rank: 99 });
            return deck.sort(() => Math.random() - 0.5);
        }

        function dealCards(deck, numPlayers) {
            const hands = Array(numPlayers).fill(0).map(() => []);
            deck.forEach((card, i) => hands[i % numPlayers].push(card));
            hands.forEach(hand => sortHand(hand));
            return hands;
        }

        function sortHand(hand) {
            return hand ? hand.sort((a, b) => getCardStrength(a) - getCardStrength(b)) : [];
        }

        function getCardStrength(card, isRevolution = false) {
            if (card.rank === 99) return 100;
            let rank = card.rank;
            if (rank <= 2) rank += 13;
            if (isRevolution) return 15 - rank + 2;
            return rank;
        }

        function updateGameUI(roomData) {
            const { gameState, gameData } = roomData;
            if (!gameData || !mySeatId || !myPlayerInfo) return;
            const myHand = gameData.hands[myPlayerInfo.id];
            const myCardCount = gameData.playerInfo[mySeatId]?.cardCount || 0;
            const isMyTurn = gameData.currentTurnSeatId == mySeatId;

            roomIdDisplay.textContent = currentRoomId;
            revolutionStatusDiv.textContent = gameData.isRevolution ? '革命中！' : '';
            renderMyHand(myHand || []);
            renderField(gameData.field || []);
            renderOtherPlayers(gameData.playerInfo, gameData.currentTurnSeatId);

            playButton.disabled = !isMyTurn || myCardCount === 0;
            passButton.disabled = !isMyTurn || myCardCount === 0 || gameData.field.length === 0;
            gameStatusDiv.textContent = myCardCount === 0 ? "あがり" : isMyTurn ? "あなたのターン" : "相手のターン";

            if (gameState === 'finished') showGameResults(gameData);
            else gameResultOverlay.classList.add('hidden');
        }

        function renderMyHand(hand) {
            myHandDiv.innerHTML = '';
            sortHand(hand).forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => {
                    if (playButton.disabled) return;
                    cardEl.classList.toggle('selected');
                });
                myHandDiv.appendChild(cardEl);
            });
        }

        function renderField(fieldCards) {
            fieldDiv.innerHTML = '';
            fieldCards.forEach(card => fieldDiv.appendChild(createCardElement(card)));
        }

        function renderOtherPlayers(playerInfo, currentTurnSeatId) {
            const pods = [document.getElementById('player-pod-1'), document.getElementById('player-pod-2'), document.getElementById('player-pod-3')];
            pods.forEach(p => p.classList.add('hidden'));
            const seatIds = Object.keys(playerInfo).sort();
            const myIdx = seatIds.indexOf(String(mySeatId));
            let podIndex = 0;
            for (let i = 1; i < seatIds.length; i++) {
                const pSeatId = seatIds[(myIdx + i) % seatIds.length];
                const player = playerInfo[pSeatId];
                const pod = pods[podIndex++];
                if (!pod) continue;
                pod.classList.remove('hidden');
                pod.classList.toggle('active-turn', pSeatId == currentTurnSeatId);
                pod.innerHTML = `<div class="player-name">${player.name}</div><div class="card-back-container">${Array(player.cardCount).fill('<div class="card-back"></div>').join('')}</div>`;
            }
        }

        function showGameResults(gameData) {
            gameResultOverlay.classList.remove('hidden');
            resultList.innerHTML = '';
            gameData.winners.forEach((winner, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}位: ${winner.name}`;
                resultList.appendChild(li);
            });
        }

        nextGameButton.addEventListener('click', () => {
            roomRef.once('value', snapshot => {
                const players = Object.entries(snapshot.val().seats || {});
                if (players.length > 0) initializeNewGame(players);
            });
        });

        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = `card ${card.suit}`;
            el.dataset.rank = card.rank;
            el.dataset.suit = card.suit;
            const rankDisplay = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K', 99: 'JOKER' };
            el.innerHTML = `<div class="card-rank">${rankDisplay[card.rank] || card.rank}</div>`;
            return el;
        }

        playButton.addEventListener('click', () => {
            const selectedCards = Array.from(myHandDiv.querySelectorAll('.card.selected')).map(el => ({
                rank: parseInt(el.dataset.rank), suit: el.dataset.suit,
            }));
            if (selectedCards.length === 0) return;

            roomRef.child('gameData').transaction(gameData => {
                if (!gameData || gameData.currentTurnSeatId != mySeatId) return;

                const { isValid, reason, is8Giri, isRevolutionTrigger } = isValidPlay(selectedCards, gameData.field, gameData.isRevolution);
                if (!isValid) {
                    alert(`出せません: ${reason}`);
                    return;
                }

                const newHand = gameData.hands[myPlayerInfo.id].filter(c => !selectedCards.some(sc => sc.rank === c.rank && sc.suit === c.suit));
                gameData.hands[myPlayerInfo.id] = newHand;
                gameData.playerInfo[mySeatId].cardCount = newHand.length;

                gameData.lastPlay = { cards: selectedCards, seatId: mySeatId };
                gameData.passCount = 0;

                const seatIds = Object.keys(gameData.playerInfo).sort();
                const activePlayerSeatIds = seatIds.filter(id => gameData.playerInfo[id].cardCount > 0 || id == mySeatId);
                const currentTurnIndex = activePlayerSeatIds.indexOf(String(gameData.currentTurnSeatId));

                if (is8Giri) {
                    gameData.field = [];
                    gameData.currentTurnSeatId = mySeatId;
                } else {
                    gameData.field = selectedCards;
                    const nextPlayerIndex = (currentTurnIndex + 1) % activePlayerSeatIds.length;
                    gameData.currentTurnSeatId = activePlayerSeatIds[nextPlayerIndex];
                }

                if (isRevolutionTrigger) gameData.isRevolution = !gameData.isRevolution;

                if (newHand.length === 0) {
                    gameData.winners.push({ id: myPlayerInfo.id, name: myPlayerInfo.name });
                    const remainingPlayers = Object.values(gameData.playerInfo).filter(p => p.cardCount > 0);
                    if (remainingPlayers.length <= 1) {
                        if (remainingPlayers.length === 1) gameData.winners.push(remainingPlayers[0]);
                        roomRef.child('gameState').set('finished');
                    } else if (!is8Giri) {
                        const activePlayersAfterWin = seatIds.filter(id => gameData.playerInfo[id].cardCount > 0);
                        gameData.currentTurnSeatId = activePlayersAfterWin[currentTurnIndex % activePlayersAfterWin.length];
                    }
                }
                return gameData;
            });
        });

        passButton.addEventListener('click', () => {
            roomRef.child('gameData').transaction(gameData => {
                if (!gameData || gameData.currentTurnSeatId != mySeatId) return;
                gameData.passCount++;
                const seatIds = Object.keys(gameData.playerInfo).sort();
                const activePlayerSeatIds = seatIds.filter(id => gameData.playerInfo[id].cardCount > 0);
                const currentTurnIndex = activePlayerSeatIds.indexOf(String(gameData.currentTurnSeatId));
                gameData.currentTurnSeatId = activePlayerSeatIds[(currentTurnIndex + 1) % activePlayerSeatIds.length];

                if (gameData.passCount >= activePlayerSeatIds.length - 1) {
                    gameData.field = [];
                    gameData.passCount = 0;
                    if (gameData.lastPlay) gameData.currentTurnSeatId = gameData.lastPlay.seatId;
                }
                return gameData;
            });
        });

        function isValidPlay(playCards, fieldCards, isRevolution) {
            if (playCards.length === 0) return { isValid: false, reason: 'カードが選択されていません。' };
            const playType = getPlayType(playCards);
            if (playType.type === 'invalid') return { isValid: false, reason: '無効な組み合わせです。' };
            if (playCards.length === 1 && playCards[0].rank === 8) return { isValid: true, is8Giri: true };
            const isRevolutionTrigger = playCards.length >= 4 && playType.type !== 'invalid';

            if (!fieldCards || fieldCards.length === 0) return { isValid: true, isRevolutionTrigger };

            const fieldType = getPlayType(fieldCards);
            const isJokerOnField = fieldCards.length === 1 && fieldCards[0].rank === 99;
            if (playCards[0].rank === 99) return { isValid: true, isRevolutionTrigger };
            if (playType.count !== fieldType.count && !isJokerOnField) return { isValid: false, reason: '場のカードと同じ枚数で出してください。' };

            const playStrength = getCardStrength(playCards[0], isRevolution);
            const fieldStrength = isJokerOnField ? -1 : getCardStrength(fieldCards[0], isRevolution);
            return playStrength > fieldStrength ? { isValid: true, isRevolutionTrigger } : { isValid: false, reason: '場のカードより強いカードを出してください。' };
        }

        function getPlayType(cards) {
            if (!cards || cards.length === 0) return { type: 'invalid' };
            const count = cards.length;
            const nonJokers = cards.filter(c => c.rank !== 99);
            if (nonJokers.length === 0) return { type: 'single', count: 1 };
            const baseRank = nonJokers[0].rank;
            if (nonJokers.every(c => c.rank === baseRank)) {
                if (count >= 1) return { type: 'group', count: count };
            }
            return { type: 'invalid' };
        }
    </script>
</body>

</html>
